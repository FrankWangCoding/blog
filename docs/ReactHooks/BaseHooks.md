# Hooks简介和基本Hooks使用

## Why we need Hooks?

### Class VS Function
之前我们使用React时，是使用Class作为组件的载体的。但是使用Class组件是有点牵强的。原因如下： 
- 基本没有用到继承的特性。
- 没有用到类的实例。不会去new一个组件的实例出来。

而之前我们用的函数组件，虽然能够直观的展示UI内容，但是有一个问题。函数内部无法保存内部状态，必须是纯函数才可以。所以这就限制了函数组件的使用。

### 所以我们需要是什么？

是一个根据状态变化的函数组件。然而函数与对象不同，并没有一个实例的对象能够在多次执行之间保存状态，势必需要一个额外的空间来存储状态，观察的变化，并能触发状态的重新渲染。再进一步思考，我们是不是需要的就是这样的一个机制，能够将外部的数据绑定在函数上，当这个绑定的数据发生变化的时候，函数触发重新渲染机制即可呢？那么这个机制就是Hooks。

### Hooks的定义

在React中，Hooks是把某个目标结果钩到某个可能会变化的数据源或者事件源上，那么当被钩到的数据或事件发生变化时，产生这个目标结果的代码会重新执行，产生更新后的结果。

### Hooks的好处

- 逻辑复用
  由于Hooks关注的只是变量的变化带来的影响，所以我们可以把原来Class组件内部相同逻辑的代码整合到一起，形成一个Hooks即可。当观测到改变时，重新渲染页面。这种机制，简洁直观，不会产生额外的组件节点。
- 有助于关注分离
  在原有的Class方法中，我们有时不得不把组件的生命周期填充相同的逻辑代码。而在Hooks中，我们可以认为它是三个生命周期的结合，只需要关注变量的改变本身即可。完整的体现了React的思想，从state到view，更简单直接。

### 从类组件如何过渡到Hooks组件？
  如果使用过类组件的话，那么我们要做的就是彻底忘掉生命周期，直接考虑在Hooks中实现即可。无需关心哪一种写法对应哪一个生命周期，只需要关注变量本身即可。

### useState: 让函数具有维持状态的能力
  state是React中的一个核心机制。useState这个Hook就是用来管理state的（其实和类组件里面的this.state是一样的，只是换一种写法而已）。它可以使得函数组件具有维持状态的能力。每一次重新渲染之间，这个状态是共享的。
  下面是一个使用useState组件的例子：
  ```js
  import React, { useState } from 'react';

  function Example() {
    // 创建一个保存 count 的 state，并给初始值 0
    const [count, setCount] = useState(0);

    return (
      <div>
        <p>{count}</p>
        <button onClick={() => setCount(count + 1)}>
          +
        </button>
      </div>
    );
  }
  ```
  从中可以看出的用法如下：
  - useState(initialState)中的值是创建state的初始值，它可以是任意值，任意类型。
  - useState()的返回值是有两个元素的数组，一个是变量本身，另一个是设置变量的方法。注意变量本身是只读的，只能用设置变量的方法来改变变量，直接给变量赋值的操作是非法的。
  - 如果需要创建多个state，则需要多次调用useState来进行创建。

  useState和类组件中this.state的异同
  - 类组件中的this.state只能有一个，即类内唯一的状态管理对象，通过多个键值对来进行状态的设置。而useState可以设置多个，每一个数组都对应着一个状态和设置状态的方法。
  - useState相对于类组件中的this.state语义化更强，代码更加容易理解。

  state创建需要遵循的原则：**永远不要保存可以通过计算得到的值**，换句话说，如果这个值能直接取到，或者通过方法能够处理，且不需要维持状态，那么就没必要创建state。

  state也有自己的弊端，即**一旦组件有自己状态，意味着组件如果重新创建，就需要有恢复状态的过程，这通常会让组件变得更复杂**，比如一个组件想在服务器端请求获取一个用户列表并显示，如果把读取到的数据放到本地的 state 里，那么每个用到这个组件的地方，就都需要重新获取一遍。（组件创建的时候，都会默认使用初始值，而不会保存之前的状态值。如果需要保存之前的状态值的话，需要用到store等机制来进行处理）
