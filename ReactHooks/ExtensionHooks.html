<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>拓展Hooks | 爬坑中的王小二</title>
    <meta name="generator" content="VuePress 1.9.9">
    <link rel="icon" href="/blog/image/favicon.ico">
    <meta name="description" content="个人的一些总结，随意写写">
    
    <link rel="preload" href="/blog/assets/css/0.styles.75b0cbf8.css" as="style"><link rel="preload" href="/blog/assets/js/app.dd524133.js" as="script"><link rel="preload" href="/blog/assets/js/2.5687907e.js" as="script"><link rel="preload" href="/blog/assets/js/13.14ba96b5.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.bf869da4.js"><link rel="prefetch" href="/blog/assets/js/11.91bf9c55.js"><link rel="prefetch" href="/blog/assets/js/12.2f643498.js"><link rel="prefetch" href="/blog/assets/js/14.fab6c0ef.js"><link rel="prefetch" href="/blog/assets/js/15.5a53bf95.js"><link rel="prefetch" href="/blog/assets/js/3.a3bc1a65.js"><link rel="prefetch" href="/blog/assets/js/4.a5cccfda.js"><link rel="prefetch" href="/blog/assets/js/5.bfef3080.js"><link rel="prefetch" href="/blog/assets/js/6.2d0a63f8.js"><link rel="prefetch" href="/blog/assets/js/7.d38e45ce.js"><link rel="prefetch" href="/blog/assets/js/8.5b45d7e2.js"><link rel="prefetch" href="/blog/assets/js/9.acb11d62.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.75b0cbf8.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><!----> <span class="site-name">爬坑中的王小二</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/blog/JSRedBook/Base.html" class="nav-link">
  博客
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/blog/JSRedBook/Base.html" class="nav-link">
  博客
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>JavaScript高级程序设计笔记</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>React Hooks</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/ReactHooks/BaseHooks.html" class="sidebar-link">Hooks简介和基本Hooks使用</a></li><li><a href="/blog/ReactHooks/ExtensionHooks.html" aria-current="page" class="active sidebar-link">拓展Hooks</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/ReactHooks/ExtensionHooks.html#usecallback-缓存回调函数" class="sidebar-link">useCallback 缓存回调函数</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/ReactHooks/ExtensionHooks.html#普通的hooks方式存在的问题" class="sidebar-link">普通的Hooks方式存在的问题</a></li><li class="sidebar-sub-header"><a href="/blog/ReactHooks/ExtensionHooks.html#需要达成的目标及解决方法" class="sidebar-link">需要达成的目标及解决方法</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/ReactHooks/ExtensionHooks.html#usememo-缓存计算的结果" class="sidebar-link">useMemo 缓存计算的结果</a></li><li class="sidebar-sub-header"><a href="/blog/ReactHooks/ExtensionHooks.html#useref-在多次渲染之间共享数据" class="sidebar-link">useRef 在多次渲染之间共享数据</a></li><li class="sidebar-sub-header"><a href="/blog/ReactHooks/ExtensionHooks.html#usecontext-定义全局状态" class="sidebar-link">useContext 定义全局状态</a></li><li class="sidebar-sub-header"><a href="/blog/ReactHooks/ExtensionHooks.html#usereducer-以动作来控制状态" class="sidebar-link">useReducer 以动作来控制状态</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/ReactHooks/ExtensionHooks.html#指定初始化state" class="sidebar-link">指定初始化state</a></li></ul></li></ul></li><li><a href="/blog/ReactHooks/LifeCycleAndFunction.html" class="sidebar-link">如何正确的理解函数组件的生命周期</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>个人的零零碎碎的总结</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="拓展hooks"><a href="#拓展hooks" class="header-anchor">#</a> 拓展Hooks</h1> <h2 id="usecallback-缓存回调函数"><a href="#usecallback-缓存回调函数" class="header-anchor">#</a> useCallback 缓存回调函数</h2> <h3 id="普通的hooks方式存在的问题"><a href="#普通的hooks方式存在的问题" class="header-anchor">#</a> 普通的Hooks方式存在的问题</h3> <p>在React函数组件中，每一次的UI变化，都是通过重新执行整个函数来完成，这个和传统的Class函数有很大的区别。函数组件中并没有一个直接的方式在多次渲染之间维持一个状态。</p> <p>还是上代码，通过代码能够看出来问题的所在：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Counter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token function-variable function">handleIncrement</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
  <span class="token keyword">return</span> <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span>handleIncrement<span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token operator">+</span><span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在这个例子中，实际上，组件状态每次发生变化的时候，函数组件都会重新执行一次。然后在每一次执行的过程中，handleIncrement这个函数都会重新创建并执行。这就意味着，即使count本身没有变化，也会因为其他的状态(state)发生变化而重新渲染（跟着props来走，props整个发生了变化就会触发），每次也都会重新创建这个函数。这样的执行，虽然不影响结果的正确性，但是这是没有必要的，增加了系统的开销。更重要的是：<strong>每次创建新函数的方式会让接收事件处理函数的组件，需要重新渲染。</strong></p> <h3 id="需要达成的目标及解决方法"><a href="#需要达成的目标及解决方法" class="header-anchor">#</a> 需要达成的目标及解决方法</h3> <p>对于上面的例子来说，我们需要达成的目标就是：<strong>只有当count发生变化的时候，我们才需要定义一个回调函数</strong>，缓存这个函数从而不必要每次创建。这样就提升了性能。</p> <p>下面就需要请出主角，useCallback，这个函数的API签名如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">useCallback</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span>deps<span class="token punctuation">)</span>
</code></pre></div><p>那么上面的例子，我们需要观测，只有count变化的时候，才执行setCount的变化。可以这样改造我们的方法：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Counter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span>setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token function-variable function">handleIncrement</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">useCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>count<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 只有count发生变化的时候，才会重新创建回调函数</span>
  <span class="token keyword">return</span> <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span>handleIncrement<span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token operator">+</span><span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在这里，我们把 count 这个 state ，作为一个依赖传递给 useCallback。这样，只有 count 发生变化的时候，才需要重新创建一个回调函数，这样就保证了组件不会创建重复的回调函数。而接收这个回调函数作为属性的组件，也不会频繁地需要重新渲染。</p> <h2 id="usememo-缓存计算的结果"><a href="#usememo-缓存计算的结果" class="header-anchor">#</a> useMemo 缓存计算的结果</h2> <p>useMemo的API签名如下：</p> <div class="language-js extra-class"><pre class="language-js"><code>
<span class="token function">useMemo</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> deps<span class="token punctuation">)</span>

</code></pre></div><p>这里的fn是产生数据所需的一个计算函数（可以类比vue中的computed）。通常来说fn会使用deps中声明的一个变量来生成一个结果，从而渲染出最终的UI。</p> <p>即：<strong>如果某个数据是通过其它数据计算得到的，那么只有当用到的数据，也就是依赖的数据发生变化的时候，才应该需要重新计算</strong></p> <p>这里还是直接上代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">{</span> useState<span class="token punctuation">,</span> useEffect <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;react&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token function">SearchUserList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>users<span class="token punctuation">,</span> setUsers<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>searchKey<span class="token punctuation">,</span> setSearchKey<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">&quot;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token function-variable function">doFetch</span> <span class="token operator">=</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token comment">// 组件首次加载时发请求获取用户数据</span>
      <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">&quot;https://reqres.in/api/users/&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">setUsers</span><span class="token punctuation">(</span><span class="token keyword">await</span> res<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token function">doFetch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> usersToShow <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>users<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 无论组件为何刷新，这里一定会对数组做一次过滤的操作，会有重复的计算</span>
    <span class="token comment">// 因为没有之前的数据作比较，这里必然是会走的</span>
    usersToShow <span class="token operator">=</span> users<span class="token punctuation">.</span>data<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">user</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span>
      user<span class="token punctuation">.</span>first_name<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span>searchKey<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>input
        type<span class="token operator">=</span><span class="token string">&quot;text&quot;</span>
        value<span class="token operator">=</span><span class="token punctuation">{</span>searchKey<span class="token punctuation">}</span>
        onChange<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token parameter">evt</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">setSearchKey</span><span class="token punctuation">(</span>evt<span class="token punctuation">.</span>target<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">}</span>
      <span class="token operator">/</span><span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>ul<span class="token operator">&gt;</span>
        <span class="token punctuation">{</span>usersToShow <span class="token operator">&amp;&amp;</span>
          usersToShow<span class="token punctuation">.</span>length <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>
          usersToShow<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">user</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token operator">&lt;</span>li key<span class="token operator">=</span><span class="token punctuation">{</span>user<span class="token punctuation">.</span>id<span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token punctuation">{</span>user<span class="token punctuation">.</span>first_name<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">&gt;</span><span class="token punctuation">;</span>
          <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span>
      <span class="token operator">&lt;</span><span class="token operator">/</span>ul<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这里模拟了一个检索的功能，根据文本框的输入来搜索列表的信息。但是由于我们判断的只是user的列表是否为空，所以每次都会进行重复的计算，userToShow这个值都会重新被赋值，发生改变。然而我们并不想这样，我们期待的只是当user和searchKey发生改变的时候，才触发这个值的变化。不想要那么多无用的计算，浪费性能。所以这里就可以用到useMemo这个Hook来实现这个逻辑，将usersToShow可以改造成下面的方式：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> userToShow <span class="token operator">=</span> <span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>users<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> users<span class="token punctuation">.</span>data<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">user</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span>
    user<span class="token punctuation">.</span>first_name<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span>searchKey<span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">[</span>users<span class="token punctuation">,</span> searchKey<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// 当users和searchKey发生改变的时候，才进行重新计算，否则不会重新计算</span>
</code></pre></div><p>useMemo还有一个重要的功能：<strong>避免子组件的重复渲染。</strong> 还是拿上面的例子进行举例，如果页面的很多地方都要用到userToShow这个变量的话，每当userToShow变化，就会进行重新渲染。而当我们使用了useMemo，缓存了上一次的结果，避免了userToShow的不必要的变化，就可以避免很多不必要的组件刷新，从而提升了性能。</p> <p>如果我们这个时候把useMemo和useCallback结合来看，useMemo是可以实现useCallback的功能的。（即useMemo可以缓存一个函数，从而实现了useCallback的功能），拿下面的例子来进行举例：</p> <div class="language-js extra-class"><pre class="language-js"><code> <span class="token keyword">const</span> myEventHandler <span class="token operator">=</span> <span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
   <span class="token comment">// 返回一个函数作为缓存结果</span>
   <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
     <span class="token comment">// 在这里进行事件处理</span>
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>dep1<span class="token punctuation">,</span> dep2<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>从本质上来说，useCallback和useMemo都做了同一件事：<strong>建立了一个绑定某个结果到依赖数据的关系。只有当依赖变了，这个结果才需要被重新得到。</strong></p> <h2 id="useref-在多次渲染之间共享数据"><a href="#useref-在多次渲染之间共享数据" class="header-anchor">#</a> useRef 在多次渲染之间共享数据</h2> <p>函数组件缺少了一种能力，就是多次渲染之间，保存常量（其实也不是常量，就是不受函数控制而已）的能力。即：<strong>可以在多次渲染之间共享数据。</strong></p> <p>在类组件中，我们可以定义类的成员变量，使得我们可以在对象上的成员属性去保存一些数据。然而在函数组件中，我们是没有这样的空间去保存数据的。所以就有useRef这样一个Hooks的产生。（即多次渲染中，不变的数据可以给到这里）</p> <p>下面是useRef的API签名</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> myRefContainer <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span>initialValue<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>可以把useRef看作是在函数组件之外创建的一个容器空间。在这个容器上，我们可以通过唯一的一个current属性设置一个值，从而在函数组件的多次渲染共享这个值。（大白话：我这个变量不受函数组件的控制，你函数组件爱咋玩咋玩，我不跟你走，除非你主动改变我这上面的current值）</p> <p>下面是一个useRef使用的具体例子：</p> <div class="language-js extra-class"><pre class="language-js"><code>
<span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">{</span> useState<span class="token punctuation">,</span> useCallback<span class="token punctuation">,</span> useRef <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;react&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token function">Timer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 定义 time state 用于保存计时的累积时间</span>
  <span class="token comment">// 用于界面上的时间的显示，开始计时的时候会同步展示</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>time<span class="token punctuation">,</span> setTime<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 定义 timer 这样一个容器用于在跨组件渲染之间保存一个变量</span>
  <span class="token comment">// 其实是保存函数返回的id值，从而便于clearTimeout进行清除</span>
  <span class="token comment">// 并不需要频繁变化，只需要开始的时候存一下就好了，所以用一个不受控的useRef来存就好。</span>
  <span class="token keyword">const</span> timer <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 开始计时的事件处理函数</span>
  <span class="token keyword">const</span> handleStart <span class="token operator">=</span> <span class="token function">useCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 使用 current 属性设置 ref 的值</span>
    <span class="token comment">// 只有每次开始的时候记录就好，记录id值就可以</span>
    timer<span class="token punctuation">.</span>current <span class="token operator">=</span> window<span class="token punctuation">.</span><span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token function">setTime</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">time</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> time <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 暂停计时的事件处理函数</span>
  <span class="token keyword">const</span> handlePause <span class="token operator">=</span> <span class="token function">useCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 使用 clearInterval 来停止计时</span>
    <span class="token comment">// 因为clear事件的参数是需要清空的id值，需要完全对应，这个时候去取timer.current就可以</span>
    window<span class="token punctuation">.</span><span class="token function">clearInterval</span><span class="token punctuation">(</span>timer<span class="token punctuation">.</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>
    timer<span class="token punctuation">.</span>current <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
      <span class="token punctuation">{</span>time <span class="token operator">/</span> <span class="token number">10</span><span class="token punctuation">}</span> seconds<span class="token punctuation">.</span>
      <span class="token operator">&lt;</span>br <span class="token operator">/</span><span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span>handleStart<span class="token punctuation">}</span><span class="token operator">&gt;</span>Start<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span>handlePause<span class="token punctuation">}</span><span class="token operator">&gt;</span>Pause<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>同时，使用useRef保存的数据是与UI渲染无关的，所以当ref的值发生变化的时候，不会触发组件的重新渲染（前面提到的非受控就是如此，不受函数的控制，比较自由），这个也是useRef区别于useState的地方。</p> <p>除了存储跨渲染的数据之外，useRef还有一个重要的功能，就是<strong>保存某个DOM节点的引用。</strong> 当我们需要对DOM进行操作的时候就可以使用useRef这个Hook。（这个用法和类组件中的createRef相似）</p> <div class="language-js extra-class"><pre class="language-js"><code>
<span class="token keyword">function</span> <span class="token function">TextInputWithFocusButton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> inputEl <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token function-variable function">onButtonClick</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// current 属性指向了真实的 input 这个 DOM 节点，从而可以调用 focus 方法</span>
    inputEl<span class="token punctuation">.</span>current<span class="token punctuation">.</span><span class="token function">focus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span><span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>input ref<span class="token operator">=</span><span class="token punctuation">{</span>inputEl<span class="token punctuation">}</span> type<span class="token operator">=</span><span class="token string">&quot;text&quot;</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span>onButtonClick<span class="token punctuation">}</span><span class="token operator">&gt;</span>Focus the input<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span><span class="token operator">&gt;</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这段代码是 React 官方文档提供的一个例子，可以看到 ref 这个属性提供了获得 DOM 节点的能力，并利用 useRef 保存了这个节点的应用。这样的话，一旦 input 节点被渲染到界面上，那我们通过 inputEl.current 就能访问到真实的 DOM 节点的实例了。</p> <h2 id="usecontext-定义全局状态"><a href="#usecontext-定义全局状态" class="header-anchor">#</a> useContext 定义全局状态</h2> <p>用于跨层次或者同层级组件之间进行数据的共享，即全局状态管理。</p> <p>React提供一个Context机制，这样所有从这个组件衍生出来的组件，都能访问到这个Context，从而进行访问和修改这个Context。那么在函数组件里，我们就可以使用useContext这样一个Hook来管理Context。</p> <p>useContext函数原型如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> value <span class="token operator">=</span> <span class="token function">useContext</span><span class="token punctuation">(</span>MyContext<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// MyContext为创建的Context，作为公用的上下文信息，在子组件中可以取得这个值</span>
</code></pre></div><p>而我们创建Context的API是这样用的：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> MyContext <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">createContext</span><span class="token punctuation">(</span>initialValue<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//这样我们创建了一个上下文信息。可以通过导入的方式来引用同一个信息，从而进行值的修改</span>
</code></pre></div><p>创建出来的这个MyContext是有一个Provider属性的，可以有一个value值，应用到它所管控的所有上下文中，这样我们useContext获取到的，就是这个value的值。比如下面的这个例子。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> themes <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">light</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">foreground</span><span class="token operator">:</span> <span class="token string">&quot;#000000&quot;</span><span class="token punctuation">,</span>
    <span class="token literal-property property">background</span><span class="token operator">:</span> <span class="token string">&quot;#eeeeee&quot;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">dark</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">foreground</span><span class="token operator">:</span> <span class="token string">&quot;#ffffff&quot;</span><span class="token punctuation">,</span>
    <span class="token literal-property property">background</span><span class="token operator">:</span> <span class="token string">&quot;#222222&quot;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// 创建一个 Theme 的 Context，其实如果是多文件的情况，可以对它单独进行文件管理进行导出。默认的主题是浅色。</span>
<span class="token keyword">const</span> ThemeContext <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">createContext</span><span class="token punctuation">(</span>themes<span class="token punctuation">.</span>light<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 整个应用使用 ThemeContext.Provider 作为根组件</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token comment">// 使用 themes.dark 作为当前 Context，它下面所管控的所有的组件如果用到了这个上下文，都会进行变化。</span>
    <span class="token comment">// 在这个例子里面，只有Toolbar</span>
    <span class="token operator">&lt;</span>ThemeContext<span class="token punctuation">.</span>Provider value<span class="token operator">=</span><span class="token punctuation">{</span>themes<span class="token punctuation">.</span>dark<span class="token punctuation">}</span><span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>Toolbar <span class="token operator">/</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>ThemeContext<span class="token punctuation">.</span>Provider<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 在 Toolbar 组件中使用一个会使用 Theme 的 Button</span>
<span class="token keyword">function</span> <span class="token function">Toolbar</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>ThemedButton <span class="token operator">/</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 在 Theme Button 中使用 useContext 来获取当前的主题</span>
<span class="token keyword">function</span> <span class="token function">ThemedButton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> theme <span class="token operator">=</span> <span class="token function">useContext</span><span class="token punctuation">(</span>ThemeContext<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 在这里拿到了这个上下文，也就是我们在外面传递的深色。</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>button style<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">{</span>
      <span class="token literal-property property">background</span><span class="token operator">:</span> theme<span class="token punctuation">.</span>background<span class="token punctuation">,</span>
      <span class="token literal-property property">color</span><span class="token operator">:</span> theme<span class="token punctuation">.</span>foreground
    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&gt;</span>
      <span class="token constant">I</span> am styled by theme context<span class="token operator">!</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这里当Context发生变化的时候，它下面的数据都会自动刷新，重新进行渲染。这也是为什么React设计如此复杂的机制的问题，而不是简单的用一个全局变量的原因了。</p> <p>当我们想对主题色进行动态切换，如果我们清楚这个原理，那么思路也就变得比较简单，只需要动态改变创建的上下文的value值即可。那么下面的例子就是一个实现。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ...</span>
<span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 使用 state 来保存 theme 从而可以动态修改</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>theme<span class="token punctuation">,</span> setTheme<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">&quot;light&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 切换 theme 的回调函数</span>
  <span class="token keyword">const</span> toggleTheme <span class="token operator">=</span> <span class="token function">useCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">setTheme</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">theme</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span>theme <span class="token operator">===</span> <span class="token string">&quot;light&quot;</span> <span class="token operator">?</span> <span class="token string">&quot;dark&quot;</span> <span class="token operator">:</span> <span class="token string">&quot;light&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token comment">// 使用 theme state 作为当前 Context</span>
    <span class="token operator">&lt;</span>ThemeContext<span class="token punctuation">.</span>Provider value<span class="token operator">=</span><span class="token punctuation">{</span>themes<span class="token punctuation">[</span>theme<span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span>toggleTheme<span class="token punctuation">}</span><span class="token operator">&gt;</span>Toggle Theme<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>Toolbar <span class="token operator">/</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>ThemeContext<span class="token punctuation">.</span>Provider<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>全局变量是一把双刃剑，它可以方便在组件间共享数据，但也有如下缺点：</p> <ul><li>会让调试变得困难，因为你很难跟踪某个 Context 的变化究竟是如何产生的。</li> <li>让组件的复用变得困难，因为一个组件如果使用了某个 Context，它就必须确保被用到的地方一定有这个 Context 的 Provider 在其父组件的路径上。</li></ul> <p>所以在 React 的开发中，除了像 Theme、Language 等一目了然的需要全局设置的变量外，我们很少会使用 Context 来做太多数据的共享。需要再三强调的是，Context 更多的是提供了一个强大的机制，<strong>让 React 应用具备定义全局的响应式数据的能力。</strong></p> <h2 id="usereducer-以动作来控制状态"><a href="#usereducer-以动作来控制状态" class="header-anchor">#</a> useReducer 以动作来控制状态</h2> <p>注：这部分内容来自于React官方文档。</p> <p>useReducer是useState的替代方案。它比useState的好处在于，当state的逻辑较为复杂且包含多个子值或者下一个state依赖于之前的state时，它的适用度要比useState更广。它接收一个形如 (state, action) =&gt; newState 的 reducer，并返回当前的 state 以及与其配套的 dispatch 方法。
useReducer也可以给触发深更新的组件做性能优化。（这个涉及到useContext和useReducer的联用，可以模拟Redux的效果）</p> <p>个人理解是有点类似于批量操作的意思，这个dispatch的方法，是可以进行批量的状态变更的。如果某个状态是依赖于其它状态的之前的状态，这个也是可以取到的。</p> <p>下面是官方文档的代码示例：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> initialState <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">reducer</span><span class="token punctuation">(</span><span class="token parameter">state<span class="token punctuation">,</span> action</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">switch</span> <span class="token punctuation">(</span>action<span class="token punctuation">.</span>type<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> <span class="token string">'increment'</span><span class="token operator">:</span>
      <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token literal-property property">count</span><span class="token operator">:</span> state<span class="token punctuation">.</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> <span class="token string">'decrement'</span><span class="token operator">:</span>
      <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token literal-property property">count</span><span class="token operator">:</span> state<span class="token punctuation">.</span>count <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">default</span><span class="token operator">:</span>
      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">Counter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>state<span class="token punctuation">,</span> dispatch<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useReducer</span><span class="token punctuation">(</span>reducer<span class="token punctuation">,</span> initialState<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span><span class="token operator">&gt;</span>
      <span class="token literal-property property">Count</span><span class="token operator">:</span> <span class="token punctuation">{</span>state<span class="token punctuation">.</span>count<span class="token punctuation">}</span>
      <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">'decrement'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token operator">-</span><span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">'increment'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token operator">+</span><span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span><span class="token operator">&gt;</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>注：dispatch的标识是稳定的，可以在useEffect和useCallback等需要依赖的地方省略它。</p> <h3 id="指定初始化state"><a href="#指定初始化state" class="header-anchor">#</a> 指定初始化state</h3> <p>我们也可以使用useReducer来初始化state的值。初始化值的方式有两种。将初始 state 作为第二个参数传入 useReducer 是最简单的方法。</p> <div class="language-js extra-class"><pre class="language-js"><code> <span class="token keyword">const</span> <span class="token punctuation">[</span>state<span class="token punctuation">,</span> dispatch<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useReducer</span><span class="token punctuation">(</span>
    reducer<span class="token punctuation">,</span>
    <span class="token punctuation">{</span><span class="token literal-property property">count</span><span class="token operator">:</span> initialCount<span class="token punctuation">}</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>惰性初始化</li></ul> <p>需要将初始化的函数作为第三个参数传入，作为一个初始化的状态创建函数。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 初始化的状态创建函数，当页面加载的时候，会从这里传入值</span>
<span class="token keyword">function</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token parameter">initialCount</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token literal-property property">count</span><span class="token operator">:</span> initialCount<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 管理了需要执行的动作，即action</span>
<span class="token keyword">function</span> <span class="token function">reducer</span><span class="token punctuation">(</span><span class="token parameter">state<span class="token punctuation">,</span> action</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">switch</span> <span class="token punctuation">(</span>action<span class="token punctuation">.</span>type<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> <span class="token string">'increment'</span><span class="token operator">:</span>
      <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token literal-property property">count</span><span class="token operator">:</span> state<span class="token punctuation">.</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> <span class="token string">'decrement'</span><span class="token operator">:</span>
      <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token literal-property property">count</span><span class="token operator">:</span> state<span class="token punctuation">.</span>count <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> <span class="token string">'reset'</span><span class="token operator">:</span>
      <span class="token keyword">return</span> <span class="token function">init</span><span class="token punctuation">(</span>action<span class="token punctuation">.</span>payload<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">default</span><span class="token operator">:</span>
      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">Counter</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span>initialCount<span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>state<span class="token punctuation">,</span> dispatch<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useReducer</span><span class="token punctuation">(</span>reducer<span class="token punctuation">,</span> initialCount<span class="token punctuation">,</span> init<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// dispatch的原型就是这样的，传入一个action，action中包含的是动作的类型（type），和需要设置的值（payload）</span>
  <span class="token comment">// 下面的reset实际上调用了init方法，reducer和dispatch是关联的，reducer负责action的管理，dispatch负责action的发出</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span><span class="token operator">&gt;</span>
      <span class="token literal-property property">Count</span><span class="token operator">:</span> <span class="token punctuation">{</span>state<span class="token punctuation">.</span>count<span class="token punctuation">}</span>
      <span class="token operator">&lt;</span>button
        onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">'reset'</span><span class="token punctuation">,</span> <span class="token literal-property property">payload</span><span class="token operator">:</span> initialCount<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">&gt;</span>
        Reset
      <span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">'decrement'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token operator">-</span><span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">'increment'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token operator">+</span><span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span><span class="token operator">&gt;</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>跳过dispatch</li></ul> <p>如果 Reducer Hook 的返回值与当前 state 相同，React 将跳过子组件的渲染及副作用的执行。（React 使用 Object.is 比较算法 来比较 state。）</p> <p>需要注意的是，React 可能仍需要在跳过渲染前再次渲染该组件。不过由于 React 不会对组件树的“深层”节点进行不必要的渲染，所以大可不必担心。</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">最后更新时间:</span> <span class="time">9/21/2021, 5:31:01 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/ReactHooks/BaseHooks.html" class="prev">
        Hooks简介和基本Hooks使用
      </a></span> <span class="next"><a href="/blog/ReactHooks/LifeCycleAndFunction.html">
        如何正确的理解函数组件的生命周期
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.dd524133.js" defer></script><script src="/blog/assets/js/2.5687907e.js" defer></script><script src="/blog/assets/js/13.14ba96b5.js" defer></script>
  </body>
</html>
