<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Hooks简介和基本Hooks使用 | 爬坑中的王小二</title>
    <meta name="generator" content="VuePress 1.9.9">
    <link rel="icon" href="/blog/image/favicon.ico">
    <meta name="description" content="个人的一些总结，随意写写">
    
    <link rel="preload" href="/blog/assets/css/0.styles.75b0cbf8.css" as="style"><link rel="preload" href="/blog/assets/js/app.dd524133.js" as="script"><link rel="preload" href="/blog/assets/js/2.5687907e.js" as="script"><link rel="preload" href="/blog/assets/js/12.2f643498.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.bf869da4.js"><link rel="prefetch" href="/blog/assets/js/11.91bf9c55.js"><link rel="prefetch" href="/blog/assets/js/13.14ba96b5.js"><link rel="prefetch" href="/blog/assets/js/14.fab6c0ef.js"><link rel="prefetch" href="/blog/assets/js/15.5a53bf95.js"><link rel="prefetch" href="/blog/assets/js/3.a3bc1a65.js"><link rel="prefetch" href="/blog/assets/js/4.a5cccfda.js"><link rel="prefetch" href="/blog/assets/js/5.bfef3080.js"><link rel="prefetch" href="/blog/assets/js/6.2d0a63f8.js"><link rel="prefetch" href="/blog/assets/js/7.d38e45ce.js"><link rel="prefetch" href="/blog/assets/js/8.5b45d7e2.js"><link rel="prefetch" href="/blog/assets/js/9.acb11d62.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.75b0cbf8.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><!----> <span class="site-name">爬坑中的王小二</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/blog/JSRedBook/Base.html" class="nav-link">
  博客
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/blog/JSRedBook/Base.html" class="nav-link">
  博客
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>JavaScript高级程序设计笔记</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>React Hooks</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/ReactHooks/BaseHooks.html" aria-current="page" class="active sidebar-link">Hooks简介和基本Hooks使用</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/ReactHooks/BaseHooks.html#why-we-need-hooks" class="sidebar-link">Why we need Hooks?</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/ReactHooks/BaseHooks.html#class-vs-function" class="sidebar-link">Class VS Function</a></li><li class="sidebar-sub-header"><a href="/blog/ReactHooks/BaseHooks.html#所以我们需要是什么" class="sidebar-link">所以我们需要是什么？</a></li><li class="sidebar-sub-header"><a href="/blog/ReactHooks/BaseHooks.html#hooks的定义" class="sidebar-link">Hooks的定义</a></li><li class="sidebar-sub-header"><a href="/blog/ReactHooks/BaseHooks.html#hooks的好处" class="sidebar-link">Hooks的好处</a></li><li class="sidebar-sub-header"><a href="/blog/ReactHooks/BaseHooks.html#从类组件如何过渡到hooks组件" class="sidebar-link">从类组件如何过渡到Hooks组件？</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/ReactHooks/BaseHooks.html#两个基本hooks-usestate和useeffect" class="sidebar-link">两个基本Hooks：useState和useEffect</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/ReactHooks/BaseHooks.html#usestate-让函数具有维持状态的能力" class="sidebar-link">useState: 让函数具有维持状态的能力</a></li><li class="sidebar-sub-header"><a href="/blog/ReactHooks/BaseHooks.html#useeffect-执行副作用" class="sidebar-link">useEffect: 执行副作用</a></li><li class="sidebar-sub-header"><a href="/blog/ReactHooks/BaseHooks.html#理解hooks中的依赖" class="sidebar-link">理解Hooks中的依赖</a></li><li class="sidebar-sub-header"><a href="/blog/ReactHooks/BaseHooks.html#掌握hooks的使用规则" class="sidebar-link">掌握Hooks的使用规则</a></li></ul></li></ul></li><li><a href="/blog/ReactHooks/ExtensionHooks.html" class="sidebar-link">拓展Hooks</a></li><li><a href="/blog/ReactHooks/LifeCycleAndFunction.html" class="sidebar-link">如何正确的理解函数组件的生命周期</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>个人的零零碎碎的总结</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="hooks简介和基本hooks使用"><a href="#hooks简介和基本hooks使用" class="header-anchor">#</a> Hooks简介和基本Hooks使用</h1> <p>注：本章节所有内容几乎都是从极客时间专栏王沛老师的《React Hooks 核心原理与实战》整理而来，有一些个人的理解，不一定完全准确，仅作为一些内容的总结和整理而存在。</p> <h2 id="why-we-need-hooks"><a href="#why-we-need-hooks" class="header-anchor">#</a> Why we need Hooks?</h2> <h3 id="class-vs-function"><a href="#class-vs-function" class="header-anchor">#</a> Class VS Function</h3> <p>之前我们使用React时，是使用Class作为组件的载体的。但是使用Class组件是有点牵强的。原因如下：</p> <ul><li>基本没有用到继承的特性。</li> <li>没有用到类的实例。不会去new一个组件的实例出来。</li></ul> <p>而之前我们用的函数组件，虽然能够直观的展示UI内容，但是有一个问题。函数内部无法保存内部状态，必须是纯函数才可以。所以这就限制了函数组件的使用。</p> <h3 id="所以我们需要是什么"><a href="#所以我们需要是什么" class="header-anchor">#</a> 所以我们需要是什么？</h3> <p>是一个根据状态变化的函数组件。然而函数与对象不同，并没有一个实例的对象能够在多次执行之间保存状态，势必需要一个额外的空间来存储状态，观察的变化，并能触发状态的重新渲染。再进一步思考，我们是不是需要的就是这样的一个机制，能够将外部的数据绑定在函数上，当这个绑定的数据发生变化的时候，函数触发重新渲染机制即可呢？那么这个机制就是Hooks。</p> <h3 id="hooks的定义"><a href="#hooks的定义" class="header-anchor">#</a> Hooks的定义</h3> <p>在React中，Hooks是把某个目标结果钩到某个可能会变化的数据源或者事件源上，那么当被钩到的数据或事件发生变化时，产生这个目标结果的代码会重新执行，产生更新后的结果。</p> <h3 id="hooks的好处"><a href="#hooks的好处" class="header-anchor">#</a> Hooks的好处</h3> <ul><li>逻辑复用
由于Hooks关注的只是变量的变化带来的影响，所以我们可以把原来Class组件内部相同逻辑的代码整合到一起，形成一个Hooks即可。当观测到改变时，重新渲染页面。这种机制，简洁直观，不会产生额外的组件节点。</li> <li>有助于关注分离
在原有的Class方法中，我们有时不得不把组件的生命周期填充相同的逻辑代码。而在Hooks中，我们可以认为它是三个生命周期的结合，只需要关注变量的改变本身即可。完整的体现了React的思想，从state到view，更简单直接。</li></ul> <h3 id="从类组件如何过渡到hooks组件"><a href="#从类组件如何过渡到hooks组件" class="header-anchor">#</a> 从类组件如何过渡到Hooks组件？</h3> <p>如果使用过类组件的话，那么我们要做的就是彻底忘掉生命周期，直接考虑在Hooks中实现即可。无需关心哪一种写法对应哪一个生命周期，只需要关注变量本身即可。</p> <h2 id="两个基本hooks-usestate和useeffect"><a href="#两个基本hooks-usestate和useeffect" class="header-anchor">#</a> 两个基本Hooks：useState和useEffect</h2> <h3 id="usestate-让函数具有维持状态的能力"><a href="#usestate-让函数具有维持状态的能力" class="header-anchor">#</a> useState: 让函数具有维持状态的能力</h3> <p>state是React中的一个核心机制。useState这个Hook就是用来管理state的（其实和类组件里面的this.state是一样的，只是换一种写法而已）。它可以使得函数组件具有维持状态的能力。每一次重新渲染之间，这个状态是共享的。
下面是一个使用useState组件的例子：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">{</span> useState <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">Example</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 创建一个保存 count 的 state，并给初始值 0</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>p<span class="token operator">&gt;</span><span class="token punctuation">{</span>count<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">&gt;</span>
        <span class="token operator">+</span>
      <span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>从中可以看出的用法如下：</p> <ul><li>useState(initialState)中的值是创建state的初始值，它可以是任意值，任意类型。</li> <li>useState()的返回值是有两个元素的数组，一个是变量本身，另一个是设置变量的方法。注意变量本身是只读的，只能用设置变量的方法来改变变量，直接给变量赋值的操作是非法的。</li> <li>如果需要创建多个state，则需要多次调用useState来进行创建。</li></ul> <p>useState和类组件中this.state的异同</p> <ul><li>类组件中的this.state只能有一个，即类内唯一的状态管理对象，通过多个键值对来进行状态的设置。而useState可以设置多个，每一个数组都对应着一个状态和设置状态的方法。</li> <li>useState相对于类组件中的this.state语义化更强，代码更加容易理解。</li></ul> <p>state创建需要遵循的原则：<strong>永远不要保存可以通过计算得到的值</strong>，换句话说，如果这个值能直接取到，或者通过方法能够处理，且不需要维持状态，那么就没必要创建state。</p> <p>state也有自己的弊端，即<strong>一旦组件有自己状态，意味着组件如果重新创建，就需要有恢复状态的过程，这通常会让组件变得更复杂</strong>，比如一个组件想在服务器端请求获取一个用户列表并显示，如果把读取到的数据放到本地的 state 里，那么每个用到这个组件的地方，就都需要重新获取一遍。（组件创建的时候，都会默认使用初始值，而不会保存之前的状态值。如果需要保存之前的状态值的话，需要用到store等机制来进行处理）</p> <h3 id="useeffect-执行副作用"><a href="#useeffect-执行副作用" class="header-anchor">#</a> useEffect: 执行副作用</h3> <p>useEffect用来执行一段副作用，so，副作用？这是个啥玩意儿？通常来说，副作用是指**一段和当前执行结果无关的的代码。**即在函数组件当次的渲染过程中，useEffect中的代码执行是不影响渲染出来的UI的（不影响UI本身的渲染，例如DOM元素、组件等，但可以使得其中的数据变化）。</p> <p>useEffect接收两个参数，函数签名如下：</p> <div class="language-js extra-class"><pre class="language-js"><code>  <span class="token function">useEffect</span><span class="token punctuation">(</span>callback<span class="token punctuation">,</span>dependencies<span class="token punctuation">)</span>
</code></pre></div><ul><li>第一个参数callback为要执行的函数，第二个参数dependencies是依赖项数组。这个选项是可选的。</li> <li>如果不指定dependencies，那么callback就会在每一次函数组件执行完后都执行</li> <li>如果指定dependencies，那么只有依赖项中的值发生变化的时候，它才会执行。</li> <li>当指定dependencies时，基本类型无需注意什么。但引用类型需要注意，hooks中的比较是浅比较。对于层级比较深的对象，不要直接使用引用赋值，需要深拷贝出一个对象，对这个对象修改后并返回。这样传递给hooks就是一个全新的对象，依赖项发生变化后就会更新组件。</li></ul> <p>虽然说useEffect从使用上可以类比Class组件中的ComponentDidMount、ComponentDidUpdate和ComponentWillUnmount三个声明周期方法。但是建议彻底遗忘Class的声明周期，因为这个的使用和Hooks毫无关联，甚至会干扰到对Hooks本身的理解。所以只需要记住一点即可：<strong>useEffect是每次组件render完后判断依赖是否发生变化并执行即可。</strong></p> <p>下面有一个比较好的示例：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">{</span> useState<span class="token punctuation">,</span> useEffect <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;react&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">BlogView</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> id <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 设置一个本地 state 用于保存 blog 内容</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>blogContent<span class="token punctuation">,</span> setBlogContent<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// useEffect 的 callback 要避免直接的 async 函数，需要封装一下</span>
    <span class="token keyword">const</span> <span class="token function-variable function">doAsync</span> <span class="token operator">=</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token comment">// 当 id 发生变化时，将当前内容清除以保持一致性</span>
      <span class="token function">setBlogContent</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">// 发起请求获取数据</span>
      <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">/blog-content/</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>id<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">// 将获取的数据放入 state</span>
      <span class="token function">setBlogContent</span><span class="token punctuation">(</span><span class="token keyword">await</span> res<span class="token punctuation">.</span><span class="token function">text</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token function">doAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 使用 id 作为依赖项，变化时则执行副作用</span>

  <span class="token comment">// 如果没有 blogContent 则认为是在 loading 状态</span>
  <span class="token keyword">const</span> isLoading <span class="token operator">=</span> <span class="token operator">!</span>blogContent<span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span><span class="token punctuation">{</span>isLoading <span class="token operator">?</span> <span class="token string">&quot;Loading...&quot;</span> <span class="token operator">:</span> blogContent<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>useEffect还有两个特殊的用法：</p> <ul><li>没有依赖项。则每一次render后都会重新执行，上面已经提过此用法。</li> <li>空数组作为依赖项，则只在首次执行时触发。对应到Class组件就是ComponentDidMount。</li></ul> <p>此外，useEffect还<strong>允许返回一个函数，用于在组件销毁的时候做一些清理的动作</strong>。这个机制就几乎等价于类组件的componentWillUnmount。这个用法，与dependencies关联不大。注意callback的执行即可。原型如下：</p> <div class="language-js extra-class"><pre class="language-js"><code>  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>dependencies<span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="理解hooks中的依赖"><a href="#理解hooks中的依赖" class="header-anchor">#</a> 理解Hooks中的依赖</h3> <p>定义Hooks中的依赖项时需要注意的点：</p> <ul><li>依赖项中定义的变量是一定在回调函数中用到的，否则声明依赖项是没有意义的。</li> <li>依赖项一般是一个常量数组，而不是一个变量。因为一般在创建callback的时候，其实已经非常清楚需要用到哪些依赖项。</li> <li>React会使用浅比较来对比依赖项是否发生变化。所以需要特别注意数组和对象类型。如果是每次创建一个新对象，即使和之前的值是等价的（着重要关注地址是否相等，多层级的时候，要使用，而不是只关注值，引用类型尤其需要注意这一点，切记！)，也会认为是依赖项发生了变化。这是一个刚开始使用Hooks很容易导致Bug发生的地方。、</li> <li><strong>依赖项的重要作用是判断副作用是否要多次执行。</strong></li></ul> <p>下面有请我们的错误示例：</p> <div class="language-js extra-class"><pre class="language-js"><code>  <span class="token keyword">function</span> <span class="token function">Sample</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 这里在每次组件执行时创建了一个新数组</span>
    <span class="token keyword">const</span> todos <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">{</span> <span class="token literal-property property">text</span><span class="token operator">:</span> <span class="token string">'Learn hooks.'</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Todos changed.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 会不断输出这行内容</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>todos<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre></div><h3 id="掌握hooks的使用规则"><a href="#掌握hooks的使用规则" class="header-anchor">#</a> 掌握Hooks的使用规则</h3> <ul><li>只能在函数组件的顶级作用域使用</li> <li>只能在函数组件或其他Hooks中使用</li></ul> <p>如何理解顶级作用域？</p> <p>所谓顶级作用域，就是Hooks不能在循环、条件判断或者嵌套函数内执行，而必须是在顶层。同时Hooks在组件的多次渲染之间，必须按照顺序被执行。（Hooks内部其实维护了一个对应组件的执行列表，便于在多次渲染之间保持Hooks的状态，并对比）。</p> <p>这条规律可以总结如下：①所有Hooks必须执行到。②必须按顺序执行。</p> <p>如何理解只能在函数组件或其他Hooks中使用？</p> <p>Hooks 作为专门为函数组件设计的机制，使用的情况只有两种，一种是在函数组件内，另外一种则是在自定义的 Hooks 里面。可以将Hooks封装成高阶组件，从而让类组件调用。这个是Hooks组件和类组件能互通的机制之一。</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">最后更新时间:</span> <span class="time">9/21/2021, 5:31:01 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/JSRedBook/BaseContent.html" class="prev">
        基本概念
      </a></span> <span class="next"><a href="/blog/ReactHooks/ExtensionHooks.html">
        拓展Hooks
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.dd524133.js" defer></script><script src="/blog/assets/js/2.5687907e.js" defer></script><script src="/blog/assets/js/12.2f643498.js" defer></script>
  </body>
</html>
